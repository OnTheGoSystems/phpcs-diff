#!/usr/bin/env php
<?php

/**
 * Runs the phpcs-diff tool in for a git repository the current directory.
 *
 * Usage:
 *
 * phpcs-diff $start_revision $end_revision $standards
 */

namespace PHPCSDiff;

use PHPCSDiff\Log\LoggerInterface;

define( 'PHPCS_DIFF_PLUGIN_DIR', str_replace('\\', '/', dirname( dirname( __FILE__ ) ) ) );
define( 'PHPCS_DIFF_COMMAND', '"' . PHPCS_DIFF_PLUGIN_DIR . '/vendor/bin/phpcs' . '"' );
define( 'PHPCS_DIFF_STANDARDS', PHPCS_DIFF_PLUGIN_DIR . '/standards' );

const OUTPUT_BOLD = "\033[1m";
const OUTPUT_UNBOLD = "\033[21m";
const COLOR_PRIMARY = "\033[94m";
const COLOR_SECONDARY = "\033[93m";
const OUTPUT_REVERSE = "\033[7m";
const OUTPUT_UNREVERSE = "\033[27m";
const OUTPUT_RESET = "\033[0m";
const OUTPUT_UNDERLINED = "\033[4m";
const OUTPUT_UNUNDERLINED = "\033[24m";

$logo = file_get_contents( PHPCS_DIFF_PLUGIN_DIR . '/logo' );
echo "\n$logo\n" . OUTPUT_UNDERLINED . COLOR_SECONDARY . 'https://github.com/zaantar/phpcs-diff' . OUTPUT_RESET . "\n\n";

require_once PHPCS_DIFF_PLUGIN_DIR . '/vendor/autoload.php';

$getopt = new \GetOpt\GetOpt(
	[
		[ 's', 'start_revision', \GetOpt\GetOpt::REQUIRED_ARGUMENT ],
		[ 'e', 'end_revision', \GetOpt\GetOpt::REQUIRED_ARGUMENT ],
        [ 't', 'tolerance' ],
        [ 'standard' ],
        [ 'log_level' ],
        [ 'ignore_space_changes', \GetOpt\GetOpt::NO_ARGUMENT ],
        [ 'sniff_unstaged', \GetOpt\GetOpt::NO_ARGUMENT ],
        [ 'no_colours', \GetOpt\GetOpt::NO_ARGUMENT ],
	]
);

$getopt->getOption( 'tolerance', true )
    ->setMode( \GetOpt\GetOpt::OPTIONAL_ARGUMENT )
    ->setValidation( function( $value ) {
        return in_array( $value, [ 'blockers', 'warnings', 'notes', 'none' ] );
    } )
    ->setDefaultValue( 'notes' );

$getopt->getOption( 'standard', true )
	->setMode( \GetOpt\GetOpt::OPTIONAL_ARGUMENT )
	->setValidation( function( $value ) {
		return in_array( $value, [ 'WordPress', 'WordPress-VIP', 'WordPress-Core', 'WordPress-Docs', 'WordPress-Extra', 'Toolset' ] );
	} );

$getopt->getOption( 'log_level', true )
	->setMode( \GetOpt\GetOpt::OPTIONAL_ARGUMENT )
	->setValidation( 'is_numeric' )
	->setDefaultValue( LoggerInterface::WARNING );

try {
	$getopt->process();
} catch ( \GetOpt\ArgumentException $exception ) {
	file_put_contents( 'php://stderr', $exception->getMessage() . PHP_EOL );
	echo PHP_EOL . $getopt->getHelpText();
	return 1;
}

$start_revision = $getopt->getOption( 'start_revision' );
$end_revision = $getopt->getOption( 'end_revision' );
$phpcs_standard = $getopt->getOption( 'standard' );
$log_level = $getopt->getOption( 'log_level' );
$ignore_space_changes = $getopt->offsetExists( 'ignore_space_changes' );
$no_colours = $getopt->offsetExists( 'no_colours' );

$sniff_unstaged = $getopt->offsetExists( 'sniff_unstaged' );
if( $sniff_unstaged ) {
    $start_revision = 'HEAD';
    $end_revision = Backends\Git::UNSTAGED;
}

global $colour_primary, $colour_secondary;

if( $no_colours ) {
	$colour_primary = '';
	$colour_secondary = '';
} else {
    $colour_primary = COLOR_PRIMARY;
    $colour_secondary = COLOR_SECONDARY;
}

$logger = new Log\ShellLogger( (int) $log_level );
$options = [ 'ignore-space-change' => $ignore_space_changes ];
$version_control = new Backends\Git( '', $logger, $options );
$controller = new Main( $version_control, $logger, $options );
$controller->set_phpcs_standard( $phpcs_standard );

try {
	$found_issues = $controller->run( $start_revision, $end_revision, '' );
} catch ( \Exception $e ) {
	$logger->log(
		LoggerInterface::ERROR,
		'Uncaught exception when processing the repository in ' . $e->getFile() . ' on line ' . $e->getLine() . PHP_EOL
		. $e->getMessage() . PHP_EOL
		. 'Trace: ' . $e->getTraceAsString()
	);

	exit(1);
}


function render_line( $filename, $line, $column, $message, $source ) {
	global $colour_primary, $colour_secondary;
    return OUTPUT_BOLD . $colour_primary . "* " . $filename . ":" . $line . ':' . $column . OUTPUT_UNBOLD . PHP_EOL
        . "\t" . $source . ": " . PHP_EOL
        . "\t" . $colour_secondary . $message . OUTPUT_RESET;
}

$blockers = $warnings = $notes = [];
foreach ( $found_issues as $filename => $issues ) {
	foreach ( $issues as $line => $line_issues ) {
		foreach( $line_issues as $issue ) {
		    $output = render_line( $filename, $line, $issue['column'],  $issue['message'], $issue['source'] );

			if ( 'ERROR' === $issue['level'] ) {
				$blockers[] = $output;
			} else if ( 'WARNING' === $issue['level'] ) {
				$warnings[] = $output;
			} else if ( 'NOTE' === $issue['level'] ) {
				$notes[] = $output;
			}
		}
	}
}

function echo_chapter( $title, $items ) {
	global $colour_primary;

    if( empty( $items ) ) {
        return;
    }

	echo OUTPUT_REVERSE . OUTPUT_BOLD . $colour_primary . "### " . $title . OUTPUT_RESET . PHP_EOL . PHP_EOL;
	foreach ( $items as $item ) {
		echo $item . PHP_EOL;
	}

	echo PHP_EOL;
}

echo PHP_EOL;
echo_chapter( 'Blockers', $blockers );
echo_chapter( 'Warnings', $warnings );
echo_chapter( 'Notes', $notes );
printf(
        "\nAnalysis completed with %s blockers, %s warnings and %s notes.\n",
        count( $blockers ), count( $warnings ), count( $notes )
);

$tolerance = $getopt->getOption( 'tolerance' );
if( 'blockers' === $tolerance ) {
    exit(0);
} elseif( empty( $blockers ) ) {
    if( 'warnings' === $tolerance ) {
	    exit(0);
    } elseif( empty( $warnings ) ) {
        if( 'notes' === $tolerance || empty( $notes ) ) {
	        exit(0);
        }
    }
}

exit(1);